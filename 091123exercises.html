<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<h1> This is homework for JS intermediate Concepts 09/11/2023</h1>

<h2> use dev tools and open the console to view JS work</h2>

<body>
<script>

// "this" in global binding
//console.log ("this' in Glogal Scope", this);

//"This is implicit binding"
const classroom={
    name:'High Five',
    students: ['Valory', 'Zane', 'Joey'],
    printStudents: function(){
        console.log("this' in implicit scope(Function Dec):", this.students);

    },
    printStudentsES6: ()=>console.log("this' in Implicit Scope(ES6):",this.students),

};
classroom.printStudents();// returns student array
classroom.printStudentsES6();//returns undefined

//explicit binding
const getName=function () {
    console.log("This' in explicit Scope:",this.name);

};
const player={ 
    name: 'Royce',
    isHappy: true,
    isTall: false,
};
getName.call(player);//returns "royce"

//when using implicit binding, what typpe of fucntion
//do I use to ensure "this" does not apply to the window 
//object?

//constructor binding
function Company(name){
    this.name=name;
}
const codefi= new Company('Codefi');
console.log("this' in Constructor Scope:", codefi.name);
//returns "this' in constructor scope: Codefi"


// basic class definition
class Animal{
    constructor(name){
        this.name=name;
    }
    speak(){
        console.log(`${this.name} makes a sound!`);
    
    }
}
const dog= new Animal('Rover');
dog.speak();//Rover makes a sound

const duck=new Animal('Daffy');
duck.speak();// output: Daffy makes a sound
// this is intteresting, I can see some practical applications with this

//Getters and Setters
class Square{
    constructor(width,height){
        this._width=width;
        this._height=height;
    }
    get area(){
        return this._width * this._height;
    }
    set dimensions(value) {
        [this._width, this._height]=value;

    }
}
const square=new Square(4, 4);
console.log(square.area);// appears this creates a new objecct of the class

square.dimensions = [2,2];
console.log(square.area);// appears this creates different dimensions for the 
//above object, NOTICE that I need [] instead of () for the dimensions to work

const square1=new Square(5, 5);
console.log(square1.area);//this creates a new object in the class, returns 25

//static methods
class calculator{
    static add(a, b){
        return a +b;
    }
}
console.log(calculator.add(5,3));//  Retunst 8. his is neat, static methods 
// seem like they present more use cases as well. Helps me to wrap my head around the
// code as I build things that I can imagine a real world application for.

//private class fields
class Circle{
    #radius;
    constructor(radius){
        this.#radius = radius;
    }
    getArea(){
        return Math.PI * this.#radius * this.#radius;
    }
}
const circle = new Circle(1);
console.log(circle.getArea());// returns the area, but not the radius
// which is "private" in this case. 
// I removed the # from radius to see what would happen and I still only returned the
//area. see below:
class Circle1{
    radius;
    constructor(radius){
        this.radius = radius;
    }
    getArea(){
        return Math.PI * this.radius * this.radius;
    }
}
const circle1 = new Circle(1);
console.log(circle.getArea());
// I dont see a difference- need to study prive class fields further

// THe "this" keyword in classes
class Dog{
    constructor(name){
        this.name=name;// "this" refers to the instance, in this case Dog
    }
}

//Inside class methods: This refers to the object on which the method is called
class cat{
    constructor(name){
        this.name=name;
    }
    meow(){
        console.log(`${this.name} says meow`);//'this' refers to cat class
    }
}
const Taro=new cat('Taro');
Taro.meow();// returns taro says meow

// static methods are associated with the class, not an instance. The cannot be called on
//instances and usually serve utility purposes.
//Example
class Utils{
    static squareNumber(num){
        return num * num;
    }
}
console.log(Utils.squareNumber(4));// returns the square of the number
//I can see real world use cases for static methods like this.

//getters and setters:
//these are special methods that provide a way to access and set private class properties. 
//They can also include additional logic.
//Example:
class Box{
    #width;
    constructor(width){
        this.#width=width;
    }
    get width(){
        return this.#width;
    }
    set width(value){
        if (value< 0){
            console.log('width cannot be negative!');
        } else{
            this.width=value;
        }
    }
}

const box= new Box(100);
console.log(box.width);
box.width=-5;// If I remove the hashtags, the 'width cannot be negative' return is broken

//~Exercise 1~//






</script>






    
</body>







</html>